from pymtl3 import *
from pymtl3.stdlib.ifcs import SendIfcRTL, RecvIfcRTL

# Word Module (o singurÄƒ chunk)

class Word( Component ):
    def construct( s, nbits=32 ):
        s.in_ = InPort(nbits)
        s.in_carry = InPort(1)
        s.out = OutPort(nbits)
        s.out_carry = OutPort(1)


# Adder
class Adder( Component ):
    def construct( s, nbits=32 ):
        s.a = InPort(nbits)
        s.b = InPort(nbits)
        s.cin = InPort(1)
        s.sum = OutPort(nbits)
        s.cout = OutPort(1)

        @update
        def add_logic():
            tmp = s.a + s.b + s.cin
            s.sum @= tmp & ((1 << nbits)-1)
            s.cout @= (tmp >> nbits) & 1

# Subtractor Module
class Subtractor( Component ):
    def construct( s, nbits=32 ):
        s.a = InPort(nbits)
        s.b = InPort(nbits)
        s.borrow_in = InPort(1)
        s.diff = OutPort(nbits)
        s.borrow_out = OutPort(1)

        @update
        def sub_logic():
            tmp = s.a - s.b - s.borrow_in
            if tmp < 0:
                s.diff @= tmp + (1 << nbits)
                s.borrow_out @= 1
            else:
                s.diff @= tmp
                s.borrow_out @= 0

# Multiplier Module 
class Multiplier( Component ):
    def construct( s, nbits=32 ):
        s.a = InPort(nbits)
        s.b = InPort(nbits)
        s.prod_low = OutPort(nbits)
        s.prod_high = OutPort(nbits)

        @update
        def mult_logic():
            tmp = s.a * s.b
            s.prod_low @= tmp & ((1 << nbits)-1)
            s.prod_high @= (tmp >> nbits) & ((1 << nbits)-1)


# BigInt ALU 
class BigIntALU( Component ):
    def construct( s, n_chunks=4, nbits=32 ):
        s.a = [InPort(nbits) for _ in range(n_chunks)]
        s.b = [InPort(nbits) for _ in range(n_chunks)]
        s.sum = [OutPort(nbits) for _ in range(n_chunks)]
        s.carry_out = OutPort(1)

        s.adders = [Adder(nbits=nbits) for _ in range(n_chunks)]

        @update
        def alu_add():
            carry = 0
            for i in range(n_chunks):
                s.adders[i].a @= s.a[i]
                s.adders[i].b @= s.b[i]
                s.adders[i].cin @= carry
                s.sum[i] @= s.adders[i].sum
                carry = s.adders[i].cout
            s.carry_out @= carry
